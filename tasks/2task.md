## &nbsp;&nbsp;&nbsp;&nbsp; С++. Создание объектов в стеке и в свободной памяти. Деструкторы.
### &nbsp;&nbsp;&nbsp;&nbsp; Создание объектов в стеке

>- **Стек** — это структура данных, которая работает по принципу **FILO** *(first in — last out; первый пришел — последний ушел)*. В C++ уже есть готовый шаблон — stack.
>- **Стек** — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO 

&nbsp;&nbsp;&nbsp;&nbsp; *В стеке элемент, который вошел самый первый — выйдет самым последним.*  

 ![Tux, the Linux mascot](https://lh5.googleusercontent.com/EObIxhEydIeK35xf0dCpIsNcZqrYiaIc5B7MiNnnyly01JYxjkDs7oDBHtlN-z55jgpbfeK3wrFnyHknZ5Zq4rBoaKPQJ0B8S6eTlpm2uKESX4PKYcRZRTVXoz7PGmx2Rssi1BIe)  

&nbsp;&nbsp;&nbsp;&nbsp; Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит к ***высокой скорости***, в особенности потому, что время цикла обновления байта стека очень мало, т.е. этот байт скорее всего привязан к кэшу процессора.  
&nbsp;&nbsp;&nbsp;&nbsp; Тем не менее, у такой строгой формы управления есть и недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме того, переменные, расположенные на стеке, всегда являются локальными.

&nbsp;&nbsp;&nbsp;&nbsp; В итоге стек позволяет управлять памятью наиболее эффективным образом — но если вам нужно использовать динамические структуры данных или глобальные переменные, то стоит обратить внимание на кучу.  


---

### &nbsp;&nbsp;&nbsp;&nbsp; Создание объектов в свободной памяти
>создаются в свободной памяти, что делает возможным изменение количества элементов, хранящихся в контейнере, во время выполнения программы

---

### &nbsp;&nbsp;&nbsp;&nbsp; Деструкторы
>&nbsp;&nbsp;&nbsp;&nbsp;<font color="yellow"> — это функция-член, которая вызывается автоматически при выходе объекта из области действия или явно уничтожена вызовом **delete**. Деструктор имеет то же имя, что и класс, перед которым предшествует тильда **(~)**. Например, деструктор для класса **String** объявляется следующим образом: **~String()**.  </font>

#### &nbsp;&nbsp;&nbsp;&nbsp; Рассмотрим следующее объявление класса String:
```
// spec1_destructors.cpp
#include <string>

class String {
public:
   String( char *ch );  // Declare constructor
   ~String();           //  and destructor.
private:
   char    *_text;
   size_t  sizeOfText;
};
```
&nbsp;&nbsp;&nbsp;&nbsp;При объявлении деструкторов действуют несколько правил.  
&nbsp;&nbsp;&nbsp;&nbsp;Деструкторы:

+ **Не** могут иметь **аргументов**.

+ **Не возвращайте** значение (или void).

+ **Невозможно объявить как const, volatileили static.** *Однако их можно вызвать для уничтожения объектов, объявленных как const, volatileили static.*

+ **Может быть объявлен как virtual.** Используя виртуальные деструкторы, можно уничтожать объекты, не зная их тип — правильный деструктор для объекта вызывается с помощью механизма виртуальных функций. Обратите внимание, что для абстрактных классов деструкторы также могут объявляться как чисто виртуальные функции.

#### &nbsp;&nbsp;&nbsp;&nbsp;Порядок уничтожения

&nbsp;&nbsp;&nbsp;&nbsp;Деструкторы вызываются в порядке, обратном порядку их объявления.
