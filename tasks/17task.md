## &nbsp;&nbsp;&nbsp;&nbsp;C++.«Умные» указатели.
&nbsp;&nbsp;&nbsp;&nbsp;*Все умные указатели доступны через включение соответствующего хедера (#include memory).*
> + std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом;  

> + std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет;  
 
> + std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик.  

&nbsp;&nbsp;&nbsp;&nbsp;программисты решили, что с них хватит, и придумали правило, заключающееся в том, чтобы никогда не использовать new/delete. Как – увидим ниже.  

&nbsp;&nbsp;&nbsp;&nbsp;Помимо проблем непосредственно с new/delete, существует проблема и с простыми указателями. Она заключается в сложности разделения указателей, которые владеют объектом (owning pointer), а значит, и ответственны за вызов new/delete, и указателей, которые используют объект (non owning pointer).  

&nbsp;&nbsp;&nbsp;&nbsp;При использование простых указателей (также известных как raw pointers) невозможно без дополнительных комментариев или дополнительного изучения кода определить, какой указатель объектом владеет, а какой – только использует.  

---

### &nbsp;&nbsp;&nbsp;&nbsp; std::unique_ptr

&nbsp;&nbsp;&nbsp;&nbsp;Первым умным указателем, с которым мы познакомимся, будет std::unique_ptr [3]. Он ссылается на объект в динамической памяти и при выходе из области видимости уничтожает хранимый объект. Взглянем на пример кода ниже:
```
Листинг 5
        
{
    std::unique_ptr<X> ptr(new X()); 
    //Объект класса X создан в динамической памяти
} 
//Здесь указатель ptr покидает свою область видимости и уничтожается, 
//но перед этим удаляет из памяти объект, на который указывает
```

&nbsp;&nbsp;&nbsp;&nbsp;Когда **std::unique_ptr** выходит из области видимости, утечки памяти не происходит, потому что в своем деструкторе умный указатель вызывает **delete** для объекта на который ссылается, высвобождая тем самым память.

---

### &nbsp;&nbsp;&nbsp;&nbsp; std::shared_ptr

>&nbsp;&nbsp;&nbsp;&nbsp;Этот умный указатель разрешает объекту иметь несколько владельцев, а когда все владельцы уничтожаются, уничтожается и объект. Такое поведение достигается за счёт наличия специального счётчика ссылок внутри std::shared_ptr. Каждый раз, когда такой указатель копируется, счётчик инкрементируется, а когда один из указателей уничтожается – декрементируется. В момент, когда счётчик достигает нуля, объект уничтожается. Посмотрим на код:
```
Листинг 11
        
{
    std::shared_ptr<X> ptr = std::make_shared<X>(); //Создаётся объект
    {
        std::shared_ptr<X> ptr2 = ptr; //Теперь у объекта два владельца, выраженных в виде ptr и ptr2
    } //ptr2 выходит из области видимости, но объект не освобождается, потому что есть ptr, который по-прежнему ссылается на него
} //ptr выходит из области видимости, и объект уничтожается
```

---

### &nbsp;&nbsp;&nbsp;&nbsp; std::weak_ptr


>&nbsp;&nbsp;&nbsp;&nbsp; Это фактически умный указатель non owning, предназначенный для использования именно с std::shared_ptr. Копирование std::weak_ptr не увеличивает счётчик в std::shared_ptr, а значит и не защищает объект от уничтожения. При этом всегда имеется возможность проверить, существует ли ещё объект, на который ссылается std::weak_ptr, или нет. Внимание на код:
```
Листинг 12
        
class Owner {
public:
    std::shared_ptr<X> owningPtr;

    Owner() {
        owningPtr = std::make_shared<X>();
    }
};

class User {
    std::weak_ptr<X> usingPtr;
public:
    User(std::weak_ptr<X> object) {
        usingPtr = object;
    }

    void use() {
        if (std::shared_ptr<X> object = usingPtr.lock()) { //Попытка получить оригинальный std::shared_ptr из std::weak_ptr, если возвращён пустой std::shared_ptr, значит, объект уже был удалён
	    object->func();
        } else {
            //Объект уже удалён
        }
    }
};

int main() {
    Owner owner;
    User user(owner.owningPtr);
    user.use();
}
```
>Если ничего не понятно  
>1. [раз](https://codelessons.ru/cplusplus/map-v-c-chto-eto-i-kak-s-etim-rabotat.html)  
>2. [два](https://habr.com/ru/company/piter/blog/706866/)  
